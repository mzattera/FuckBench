-- Implementation of library functions.

-- -------------------- 
-- HELPER FUNCTIONS
-- -------------------- 

-- Clears tape cells starting from _ct_start, it will clear as many cells as contained in _ct_start.
-- For example, if _ct_start=3 this will clear _ct_start and the next 2 cells on the right.
-- _ct_start must be greater than 0.
#block _clean_tape _ct_start
	moveto _ct_start
	-- unfortunately, we need to leave a 1 in first cell as a marker, this means the code for the first cell is special
	brainfuck -[        if there is at least 2 cells to clear enter the main body
	brainfuck   >[-]<   clears next cell
	brainfuck   [->+<]  copies current into next
	brainfuck   +>-     increase first cell making it 1 then move to next cell notice the next is decremented twice because the check is done immediately		         
	brainfuck   [
	brainfuck     >[-]<  clears next cell
	brainfuck     [->+<] copies current
	brainfuck     >-     next is decremented by one
	brainfuck   ] 
	brainfuck   -[+<-]   go back to the cell with 1 
	brainfuck ]
	returnfrom _ct_start
#endblock

-- ------------------
-- OUTPUT
-- ------------------

-- Local variables for output blocks
#dim _outv_0 _outv_1 _outv_2 _outv_3 _outv_4
#custom 7

-- Print value of cell x as number for ANY sized cell (ie 8bit, 16bit, etc)
-- Original algorithm from: https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_for_ANY_sized_cell_.28ie_8bit.2C_16bit.2C_etc.29
-- Notice this uses _outv_N as working area, it expects 5 of them to be available and contogue.
#block out _o_v
	set _outv_0 12
	_clean_tape _outv_0
	copy _o_v _outv_0
	moveto _outv_0
	brainfuck [>>+>+<<<-]>>>[<<<+>>>-]<<+>[<->[>++++++++++<[->-[>+>>]>[+[-<+>]>+>>]<<<<<]>[-]
	brainfuck ++++++++[<++++++>-]>[<<+>>-]>[<<+>>-]<<]>]<[->>++++++++[<++++++>-]]<[.[-]<]<
	returnfrom _outv_0
#endblock

-- Prints value of a cell (16 bit) as decimal number, then goes newline
#block out_ln _ol_v
  out _ol_v
  line
#endblock

-- Prints value of a cell (16 bit) as hex number
#block out16 _o16_v
	msg $
	copy _o16_v _outv_0
	set _outv_1 4
	set _outv_4 4096
	uneq _outv_1 0
		divmod _outv_0 _outv_4 _outv_2 _outv_0
		multi _outv_0 16 _outv_0
		inc _outv_2 '0'
		comp _outv_2 '9' _outv_3
		ifeq _outv_3 0
			inc _outv_2 7
		end
		print _outv_2
		dec _outv_1 1
	end
#endblock

-- Prints value of a cell (16 bit) as number, then goes newline
#block out_ln16 _ol16_v
  out16 _ol16_v
  line
#endblock

-- Prints value of a cell (8 bit) as binary number
#block out_byte_2 _ob2_v
	copy _ob2_v _outv_0
	set _outv_1 8

	uneq _outv_1 0
		comp _outv_0 127 _outv_2
		ifeq _outv_2 0
			msg 1
		end
		ifnoteq _outv_2 0
			msg 0
		end
		multi _outv_0 2 _outv_0
		mod _outv_0 256 _outv_0
		dec _outv_1 1
	end
#endblock

-- Prints value of a cell (8 bit) as binary number
#block out_ln_byte_2 _olb2_v
	out_byte_2 _olb2_v
	line
#endblock


-- -----------------------------------------------------------------------------------
-- BITWISE FUNCTIONS
-- -----------------------------------------------------------------------------------

-- Implementation of bitwise operations.
-- Original code: https://codegolf.stackexchange.com/questions/9178/bitwise-operators-in-brainfuck

-- Work area for the bitwise algorithms.
-- These MUST be consecutive cell for the algorithm to work
#dim _bw_c0 _bw_c1 _bw_c2 _bw_c3 _bw_c4 _bw_c5
#custom 53

-- Resets the working area for the bitwise algorithms.
#block _clean_bw_wa
-- TODO	For each function calculate separately the working area needed and clear only that one.
	set _bw_c0 59 
	_clean_tape _bw_c0
#endblock

-- Shifts right by 1 bit (divides by 2) 
-- USES ONLY 3 CELLS
#block SHR _shr_a _shr_res
  copy _shr_a _bw_c0
  moveto _bw_c0
  brainfuck >[-]<		
  brainfuck [-[->+<]]				
  returnfrom _bw_c0
  copy _bw_c1 _shr_res
#endblock



#dim a res

set a 0
out_ln a
SHR a res
out_ln res
line

set a 3
out_ln a
SHR a res
out_ln res
line

set a 255
out_ln a
SHR a res
out_ln res
line

set a 256
out_ln a
SHR a res
out_ln res
line

set a 65535
out_ln a
SHR a res
out_ln res
line