/**
 */
package org.mzattera.bf6502;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.mzattera.util.FileUtil;

/**
 * This modifies .c files created by Esotope BrainFuck to C compiler such that:
 * 
 * 1) it has enough memory on tape reserved for 6502bf 2) tape cells are 16 bit
 * wide 3) code to read and write FBF tables is optimized
 * 
 * @author Massimiliano "Maxi" Zattera
 *
 */
public class TweakCCode {

	private final static String CODE_NAME = Linker.CODE_NAME + ".c";

	private final static int TAPE_SIZE = Linker.SKIP + 2 * 65536 + 3;

	// This is the pattern in C code when FBF reads a cell in a matrix
	// while (p[13]) {
	// --p[13];
	// p[15] += p[13];
	// p[13] = 0;
	// p += 2;
	// }
	// p[13] = p[12];
	// p[11] += p[12];
	// p[12] = p[13];
	// p[13] = 0;
	// --p[9];
	// while (p[9]) {
	// p[9] += p[11]+1;
	// p[11] = 0;
	// --p[7];
	// p -= 2;
	// }
	private static final Pattern[] READ_TABLE_PATTERN = { Pattern.compile("\\s*while \\(p\\[(\\d+)\\]\\) \\{\\s*"),
			Pattern.compile("\\s*\\-\\-p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] \\+= p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*p\\[(\\d+)] = 0;\\s*"),
			Pattern.compile("\\s*p \\+= 2;\\s*"), Pattern.compile("\\s*\\}\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] = p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] \\+= p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] = p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*p\\[(\\d+)\\] = 0;\\s*"),
			Pattern.compile("\\s*\\-\\-p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*while \\(p\\[(\\d+)\\]\\) \\{\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] \\+= p\\[(\\d+)\\]\\+1;\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] = 0;\\s*"), Pattern.compile("\\s*\\-\\-p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p \\-= 2;\\s*"), Pattern.compile("\\s*}\\s*") };

	// This is the pattern in C code when FBF writes a cell in a matrix
	// while (p[13]) {
	// --p[13];
	// p[15] += p[13];
	// p[13] = p[11];
	// p[11] = 0;
	// p += 2;
	// }
	// p[12] = p[11];
	// p[11] = 0;
	// --p[9];
	// while (p[9]) {
	// ++p[9];
	// --p[7];
	// p -= 2;
	// }
	private static final Pattern[] WRITE_TABLE_PATTERN = { Pattern.compile("\\s*while \\(p\\[(\\d+)\\]\\) \\{\\s*"),
			Pattern.compile("\\s*\\-\\-p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] \\+= p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] = p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*p\\[(\\d+)\\] = 0;\\s*"),
			Pattern.compile("\\s*p \\+= 2;\\s*"), Pattern.compile("\\s*\\}\\s*"),
			Pattern.compile("\\s*p\\[(\\d+)\\] = p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*p\\[(\\d+)\\] = 0;\\s*"),
			Pattern.compile("\\s*\\-\\-p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*while \\(p\\[(\\d+)\\]\\) \\{\\s*"),
			Pattern.compile("\\s*\\+\\+p\\[(\\d+)\\];\\s*"), Pattern.compile("\\s*\\-\\-p\\[(\\d+)\\];\\s*"),
			Pattern.compile("\\s*p \\-= 2;\\s*"), Pattern.compile("\\s*\\}\\s*") };

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try {
			String inputFileName = CODE_NAME;
			String outputFileName = CODE_NAME;
			int tapeSize = TAPE_SIZE;

			for (int i = 0; i < args.length; i++) {
				if (args[i].equals("-i"))
					inputFileName = args[++i];
				else if (args[i].equals("-o"))
					outputFileName = args[++i];
				else if (args[i].equals("-s"))
					tapeSize = Integer.parseInt(args[++i]);
				else
					throw new IllegalArgumentException("Unrecognized parameter: " + args[i]);
			}

			execute(inputFileName, outputFileName, tapeSize);
			System.exit(0);

		} catch (Exception e) {
			e.printStackTrace();
			printUsage();
			System.exit(-1);
		}
	}

	public static void execute(String inputFileName, String outputFileName, int tapeSize) throws IOException {

		// TODO Add parameters error checking

		System.out.println(TweakCCode.class.getName() + " tweaking generated code.");
		System.out.println("Input File Name : " + new File(inputFileName).getCanonicalPath());
		System.out.println("Output File Name: " + new File(outputFileName).getCanonicalPath());
		System.out.println("Total tape size : " + tapeSize);

		// Read the emulator .c code
		// String source = new String(Files.readAllBytes(Paths.get(inputFileName)));

		// Original source code
		List<String> source = Files.readAllLines(Paths.get(inputFileName));

		// New source code
		List<String> newCode = new ArrayList<>(source.size());

		// Takes opcode check source code from the emulator.
		int i = 0;

		// Fix header, tape and cell size
		for (i = 0; i < source.size(); ++i) {
			String line = source.get(i);
			if (line.equals("/* generated by esotope-bfc */")) {
				newCode.add("/* generated by esotope-bfc */");
				newCode.add("/*  optimized by FuckBench */");
			} else if (line.equals("#include <stdint.h>")) {
				newCode.add("#include <stdint.h>");
				newCode.add("#include <stddef.h>");
			} else if (line.equals("static uint8_t m[30000], *p = m;")) {
				// TODO let user choose cell size
				newCode.add("static uint16_t m[" + tapeSize + "], *p = m;");
				newCode.add("static size_t _idx = 0;");
				break;
			} else {
				newCode.add(source.get(i));
			}
		}

		// Looks for table access patterns and replace them with shorter code
		for (++i; i < source.size(); ++i) {
			String line = source.get(i);

			Matcher m = READ_TABLE_PATTERN[0].matcher(line);
			if (m.matches()) {
				// found a possible begin of a read array pattern
				String rpl = replaceRead(source, i);
				if (rpl != null) {
					newCode.add(rpl);
					i += (READ_TABLE_PATTERN.length - 1);
					continue;
				}
			}

			m = WRITE_TABLE_PATTERN[0].matcher(line);
			if (m.matches()) {
				// found a possible begin of a read array pattern
				String rpl = replaceWrite(source, i);
				if (rpl != null) {
					newCode.add(rpl);
					i += (WRITE_TABLE_PATTERN.length - 1);
					continue;
				}
			}

			newCode.add(line);
		}

		FileUtil.write(newCode, outputFileName);
	}

	/**
	 * Replaces read table pattern.
	 * 
	 * @param source Source code
	 * @param i      line in the code where the pattern starts
	 * @return null if the patters cannot be found at given line; replacement code
	 *         instead.
	 */
	private static String replaceRead(List<String> source, int i) {
		final int[] z = { 0, 0, 2, 0, 0, 0, -1, -2, -1, -1, 0, 0, -4, -4, -4, -2, -2, -6 };
		int idx = matches(source, i, READ_TABLE_PATTERN, z);
		if (idx == -1)
			return null;

		StringBuilder result = new StringBuilder(256);
		result.append("_idx = p[" + idx + "] * 2 + " + (idx - 1) + ";\n");
		result.append("p[" + (idx - 2) + "] = p[_idx];\n");
		result.append("p[" + idx + "] = 0;\n");
		result.append("p[" + (idx - 4) + "] = 0;");

		return result.toString();
	}

	/**
	 * Replaces write table pattern.
	 * 
	 * @param source Source code
	 * @param i      line in the code where the pattern starts
	 * @return null if the patters cannot be found at given line; replacement code
	 *         instead.
	 */
	private static String replaceWrite(List<String> source, int i) {
		final int[] z = { 0, 0, 2, 0, 0, -2, -2, -1, -2, -2, -4, -4, -4, -6 };
		int idx = matches(source, i, WRITE_TABLE_PATTERN, z);
		if (idx == -1)
			return null;

		StringBuilder result = new StringBuilder(256);
		result.append("_idx = p[" + idx + "] * 2 + " + (idx - 1) + ";\n");
		result.append("p[_idx] = p[" + (idx - 2) + "];\n");
		result.append("p[" + idx + "] = 0;\n");
		result.append("p[" + (idx - 4) + "] = 0;");

		return result.toString();
	}

	/**
	 * Matches table pattern.
	 * 
	 * @param source       Source code
	 * @param n            line in the code where the pattern starts.
	 * @param tablePattern Pattern we are looking to replace.
	 * @param e            This is the pattern we expect if all indexes belong to
	 *                     the right pattern
	 * @return -1 if the patters cannot be found at given line; otherwise index of
	 *         first cell used by the pattern.
	 */
	private static int matches(List<String> source, int n, Pattern[] tablePattern, int[] e) {

		// This stores numeric indices in the pattern; d[0] contains the tabs indenting
		// first line.
		int d[] = new int[e.length];
		int j = 0;

		// Makes sure each line of code matches the pattern, extract indices in the
		// process
		for (int i = 0; (i < tablePattern.length) && (n < source.size()); ++i, ++n) {
			Matcher m = tablePattern[i].matcher(source.get(n));
			if (!m.matches())
				return -1;
			for (int k = 1; k <= m.groupCount(); ++k) {
					d[j++] = Integer.parseInt(m.group(k));
			}
		}

		if (j < e.length)
			return -1;
		for (int i = 0; i < d.length; ++i) {
			if ((d[i] - d[0]) != e[i])
				return -1;
		}

		return d[1];
	}

	private static void printUsage() {
		System.out.println();
		System.out.println();
		System.out.println(
				"Usage: java -jar " + TweakCCode.class.getSimpleName() + ".jar [-i <in>] [-o <out>] [-s <size>]");
		System.out.println();
		System.out.println("    <in>   : Input .c file name (defaults to \"" + CODE_NAME + "\").");
		System.out.println(
				"    <out>  : Output .c file name; can be same of inupt file (defaults to \"" + CODE_NAME + "\").");
		System.out.println("    <size> : Total size of tape (defaults to " + TAPE_SIZE + ").");
		System.out.println();
	}
}
