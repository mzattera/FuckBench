-- Implementation of library functions (SHIFT LEFT).

-- -------------------- 
-- HELPER FUNCTIONS
-- -------------------- 

-- Clears tape cells starting from _ct_start, it will clear as many cells as contained in _ct_start.
-- For example, if _ct_start=3 this will clear _ct_start and the next 2 cells on the right.
-- _ct_start must be greater than 0.
#block _clean_tape _ct_start
	moveto _ct_start
	-- unfortunately, we need to leave a 1 in first cell as a marker, this means the code for the first cell is special
	brainfuck -[        if there is at least 2 cells to clear enter the main body
	brainfuck   >[-]<   clears next cell
	brainfuck   [->+<]  copies current into next
	brainfuck   +>-     increase first cell making it 1 then move to next cell notice the next is decremented twice because the check is done immediately		         
	brainfuck   [
	brainfuck     >[-]<  clears next cell
	brainfuck     [->+<] copies current
	brainfuck     >-     next is decremented by one
	brainfuck   ] 
	brainfuck   -[+<-]   go back to the cell with 1 
	brainfuck ]
	returnfrom _ct_start
#endblock

-- ------------------
-- OUTPUT
-- ------------------

-- Local variables for output blocks
#dim _outv_0 _outv_1 _outv_2 _outv_3 _outv_4
#custom 7

-- Print value of cell x as number for ANY sized cell (ie 8bit, 16bit, etc)
-- Original algorithm from: https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_for_ANY_sized_cell_.28ie_8bit.2C_16bit.2C_etc.29
-- Notice this uses _outv_N as working area, it expects 5 of them to be available and contogue.
#block out _o_v
	set _outv_0 12
	_clean_tape _outv_0
	copy _o_v _outv_0
	moveto _outv_0
	brainfuck [>>+>+<<<-]>>>[<<<+>>>-]<<+>[<->[>++++++++++<[->-[>+>>]>[+[-<+>]>+>>]<<<<<]>[-]
	brainfuck ++++++++[<++++++>-]>[<<+>>-]>[<<+>>-]<<]>]<[->>++++++++[<++++++>-]]<[.[-]<]<
	returnfrom _outv_0
#endblock

-- Prints value of a cell (16 bit) as decimal number, then goes newline
#block out_ln _ol_v
  out _ol_v
  line
#endblock

-- Prints value of a cell (16 bit) as hex number
#block out16 _o16_v
	msg $
	copy _o16_v _outv_0
	set _outv_1 4
	set _outv_4 4096
	uneq _outv_1 0
		divmod _outv_0 _outv_4 _outv_2 _outv_0
		multi _outv_0 16 _outv_0
		inc _outv_2 '0'
		comp _outv_2 '9' _outv_3
		ifeq _outv_3 0
			inc _outv_2 7
		end
		print _outv_2
		dec _outv_1 1
	end
#endblock

-- Prints value of a cell (16 bit) as number, then goes newline
#block out_ln16 _ol16_v
  out16 _ol16_v
  line
#endblock

-- Prints value of a cell (8 bit) as binary number
#block out_byte_2 _ob2_v
	copy _ob2_v _outv_0
	set _outv_1 8

	uneq _outv_1 0
		comp _outv_0 127 _outv_2
		ifeq _outv_2 0
			msg 1
		end
		ifnoteq _outv_2 0
			msg 0
		end
		multi _outv_0 2 _outv_0
		mod _outv_0 256 _outv_0
		dec _outv_1 1
	end
#endblock

-- Prints value of a cell (8 bit) as binary number
#block out_ln_byte_2 _olb2_v
	out_byte_2 _olb2_v
	line
#endblock


-- -----------------------------------------------------------------------------------
-- BITWISE FUNCTIONS
-- -----------------------------------------------------------------------------------

-- Work area for the bitwise algorithms.
-- These MUST be consecutive cell for the algorithm to work
#dim _bw_c0 _bw_c1

-- Shifts left (multiplies by 2)
-- IT FAILS IF THE RESULTS CAUSES AN OVERFLOW (but it is fast)
-- USES ONLY 2 CELLS
#block SHL _shl_a _shl_res
	copy _shl_a _bw_c0
	moveto _bw_c1
	brainfuck [-]<[->++<]
	returnfrom _bw_c0
	copy _bw_c1 _shl_res
#endblock

-- Shifts left by 4 positions (multiplies by 16) 
-- IT FAILS IF THE RESULTS CAUSES AN OVERFLOW (but it is fast)
-- USES ONLY 2 CELLS
#block SHL_4 _shl4_a _shl4_res
	copy _shl4_a _bw_c0
	moveto _bw_c1
	brainfuck [-]<[->++++ ++++ ++++ ++++<]
	returnfrom _bw_c0
	copy _bw_c1 _shl4_res
#endblock

-- Shifts left by 7 positions (multiplies by 128) 
-- IT FAILS IF THE RESULTS CAUSES AN OVERFLOW (but it is fast)
-- USES ONLY 2 CELLS
#block SHL_7 _shl7_a _shl7_res
	copy _shl7_a _bw_c0
	moveto _bw_c1
	brainfuck [-]<[->++++ ++++ ++++ ++++<]
	brainfuck >[-<++++ ++++>]
	returnfrom _bw_c1
	copy _bw_c0 _shl7_res
#endblock

-- Shifts left by 8 positions (multiplies by 256) 
-- IT FAILS IF THE RESULTS CAUSES AN OVERFLOW (but it is fast)
-- USES ONLY 2 CELLS
#block SHL_8 _shl8_a _shl8_res
	copy _shl8_a _bw_c0
	moveto _bw_c1
	brainfuck [-]<[->++++ ++++ ++++ ++++<]
	brainfuck >[-<++++ ++++ ++++ ++++>]
	returnfrom _bw_c1
	copy _bw_c0 _shl8_res
#endblock

-- -----------------------------------------------------------------------------------
-- TEST
-- -----------------------------------------------------------------------------------

#dim a b c d

set a 1
set c 255
copy c a
multi a 256 b
out_ln b