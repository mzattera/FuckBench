-- Implementation of library functions.

-- -------------------- 
-- HELPER FUNCTIONS
-- -------------------- 

-- Clears tape cells starting from _ct_start, it will clear as many cells as contained in _ct_start.
-- For example, if _ct_start=3 this will clear _ct_start and the next 2 cells on the right.
-- _ct_start must be greater than 0.
#block _clean_tape _ct_start
	moveto _ct_start
	-- unfortunately, we need to leave a 1 in first cell as a marker, this means the code for the first cell is special
	brainfuck -[        if there is at least 2 cells to clear enter the main body
	brainfuck   >[-]<   clears next cell
	brainfuck   [->+<]  copies current into next
	brainfuck   +>-     increase first cell making it 1 then move to next cell notice the next is decremented twice because the check is done immediately		         
	brainfuck   [
	brainfuck     >[-]<  clears next cell
	brainfuck     [->+<] copies current
	brainfuck     >-     next is decremented by one
	brainfuck   ] 
	brainfuck   -[+<-]   go back to the cell with 1 
	brainfuck ]
	returnfrom _ct_start
#endblock

-- ------------------
-- OUTPUT
-- ------------------

-- Local variables for output blocks
#dim _outv_0 _outv_1 _outv_2 _outv_3 _outv_4
#custom 7

-- Print value of cell x as number for ANY sized cell (ie 8bit, 16bit, etc)
-- Original algorithm from: https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_for_ANY_sized_cell_.28ie_8bit.2C_16bit.2C_etc.29
-- Notice this uses _outv_N as working area, it expects 5 of them to be available and contogue.
#block out _o_v
	set _outv_0 12
	_clean_tape _outv_0
	copy _o_v _outv_0
	moveto _outv_0
	brainfuck [>>+>+<<<-]>>>[<<<+>>>-]<<+>[<->[>++++++++++<[->-[>+>>]>[+[-<+>]>+>>]<<<<<]>[-]
	brainfuck ++++++++[<++++++>-]>[<<+>>-]>[<<+>>-]<<]>]<[->>++++++++[<++++++>-]]<[.[-]<]<
	returnfrom _outv_0
#endblock

-- Prints value of a cell (16 bit) as decimal number, then goes newline
#block out_ln _ol_v
  out _ol_v
  line
#endblock

-- Prints value of a cell (16 bit) as hex number
#block out16 _o16_v
	msg $
	copy _o16_v _outv_0
	set _outv_1 4
	set _outv_4 4096
	uneq _outv_1 0
		divmod _outv_0 _outv_4 _outv_2 _outv_0
		multi _outv_0 16 _outv_0
		inc _outv_2 '0'
		comp _outv_2 '9' _outv_3
		ifeq _outv_3 0
			inc _outv_2 7
		end
		print _outv_2
		dec _outv_1 1
	end
#endblock

-- Prints value of a cell (16 bit) as number, then goes newline
#block out_ln16 _ol16_v
  out16 _ol16_v
  line
#endblock

-- Prints value of a cell (8 bit) as binary number
#block out_byte_2 _ob2_v
	copy _ob2_v _outv_0
	set _outv_1 8

	uneq _outv_1 0
		comp _outv_0 127 _outv_2
		ifeq _outv_2 0
			msg 1
		end
		ifnoteq _outv_2 0
			msg 0
		end
		multi _outv_0 2 _outv_0
		mod _outv_0 256 _outv_0
		dec _outv_1 1
	end
#endblock

-- Prints value of a cell (8 bit) as binary number
#block out_ln_byte_2 _olb2_v
	out_byte_2 _olb2_v
	line
#endblock


-- -----------------------------------------------------------------------------------
-- BITWISE FUNCTIONS
-- -----------------------------------------------------------------------------------

-- Implementation of bitwise operations.
-- Original code: https://codegolf.stackexchange.com/questions/9178/bitwise-operators-in-brainfuck

-- Work area for the bitwise algorithms.
-- These MUST be consecutive cell for the algorithm to work
#dim _bw_c0 _bw_c1 _bw_c2 _bw_c3 _bw_c4 _bw_c5
#custom 53

-- Resets the working area for the bitwise algorithms.
#block _clean_bw_wa
-- TODO	For each function calculate separately the working area needed and clear only that one.
	set _bw_c0 59 
	_clean_tape _bw_c0
#endblock
	
#block NOT _not_a _not_res
	-- Assumes A is in cell 0, stores NOT A in cell 1, pointer starts and ends in cell 0.
	_clean_bw_wa
	copy _not_a _bw_c0
	moveto _bw_c0
	brainfuck +[>-<-]
	returnfrom _bw_c0
	copy _bw_c1 _not_res
#endblock


#block OR _or_a _or_b _or_res
	-- Assumes A and B are in cells 1 and 2, stores A OR B in cell 2, pointer starts in cell 0 and ends in cell 5.
	_clean_bw_wa
	copy _or_a _bw_c1
	copy _or_b _bw_c2
	moveto _bw_c0
	brainfuck -[[>>>>>>[>>>]++[-<<<]<<<-]>]>>>[<]>[[>[>+<-]>[<<<<<<+>>>>>>[-]]>]+[<[<<<++>>>-]<<]>>]
	returnfrom _bw_c5
	copy _bw_c2 _or_res
#endblock

#block AND _and_a _and_b _and_res
	-- Assumes A and B are in cells 1 and 2, stores A AND B in cell 4, pointer starts in cell 0 and ends in cell 5.
	_clean_bw_wa
	copy _and_a _bw_c1
	copy _and_b _bw_c2
	moveto _bw_c0
	brainfuck -[[>>>>>>[>>>]++[-<<<]<<<-]>]>>>[<]>[[>[>[<<<<+>>>>-]<-]>+>]<[<[<<<++>>>-]<<]]
	returnfrom _bw_c5
	copy _bw_c4 _and_res
#endblock

#block XOR _xor_a _xor_b _xor_res
	-- Assumes A and B are in cells 1 and 2, stores A XOR B in cell 2, pointer starts in cell 0 and ends in cell 5.
	_clean_bw_wa
	copy _xor_a _bw_c1
	copy _xor_b _bw_c2
	moveto _bw_c0
	brainfuck -[[>>>>>>[>>>]++[-<<<]<<<-]>]>>>[<]>[[>[>-<-]>[<<<<<<+>>>>>>[-]]>]+[<[<<<++>>>-]<<]>>]
	returnfrom _bw_c5
	copy _bw_c2 _xor_res
#endblock

-- -----------------------------------------------------------------------------------
-- MATH FUNCTIONS
-- -----------------------------------------------------------------------------------

-- Work area for math functions.
-- These MUST be consecutive cell for the algorithm to work
#dim _mf_c0 _mf_c1 _mf_c2 _mf_c3
#custom 2

-- Original code: https://esolangs.org/wiki/Brainfuck_algorithms#Divmod_algorithm
#block divmod _d_n _d_d _d_result _d_mod
	-- >n d
	-- # >0 d-n%d n%d n/d
	set _mf_c0 6
	_clean_tape _mf_c0
	copy _d_n _mf_c0
	copy _d_d _mf_c1
	moveto _mf_c0
	brainfuck [->[->+>>]>[<<+>>[-<+>]>+>>]<<<<<]
	brainfuck >[>>>]>[[-<+>]>+>>]<<<<<
	returnfrom _mf_c0
	copy _mf_c3 _d_result
	copy _mf_c2 _d_mod
#endblock

-- -----------------------------------------------------------------------------------
-- TEST
-- -----------------------------------------------------------------------------------

#block test_NOT
		
	set aaa 0 
	NOT aaa res
	msg A:
	tab
	out_ln16 aaa
	msg NOT A:
	tab
	out_ln16 res
		
	set aaa 65535
	NOT aaa res
	msg A:
	tab
	out_ln16 aaa
	msg NOT A:
	tab
	out_ln16 res
		
	set aaa 170
	NOT aaa res
	msg A:
	tab
	out_ln16 aaa
	msg NOT A:
	tab
	out_ln16 res
		
	set aaa 85
	NOT aaa res
	msg A:
	tab
	out_ln16 aaa
	msg NOT A:
	tab
	out_ln16 res
	
	line
#endblock
	
#block test_ROL
	set aaa 32768 
	ROL aaa res
	msg A:
	tab
	out_ln16 aaa
	msg ROL A:
	tab
	out_ln16 res
	
	set aaa 0 
	ROL aaa res
	msg A:
	tab
	out_ln16 aaa
	msg ROL A:
	tab
	out_ln16 res	
	
	set aaa 65535 
	ROL aaa res
	msg A:
	tab
	out_ln16 aaa
	msg ROL A:
	tab
	out_ln16 res
	
	set aaa 43605 
	ROL aaa res
	msg A:
	tab
	out_ln16 aaa
	msg ROL A:
	tab
	out_ln16 res
	
	line
#endblock

#block test_OR
	set aaa 0
	set bbb 0
	OR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A OR B:
	tab
	out_ln16 res
	
	set aaa 0
	set bbb 65535
	OR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A OR B:
	tab
	out_ln16 res	
	
	set aaa 65535
	set bbb 0
	OR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A OR B:
	tab
	out_ln16 res	
	
	set aaa 65535
	set bbb 65535
	OR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A OR B:
	tab
	out_ln16 res
	
	set aaa 43690
	set bbb 21845
	OR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A OR B:
	tab
	out_ln16 res		
	
	set aaa 43690
	set bbb 43690
	OR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A OR B:
	tab
	out_ln16 res	

	line
#endblock

#block test_AND
	set aaa 0
	set bbb 0
	AND aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A AND B:
	tab
	out_ln16 res
	
	set aaa 0
	set bbb 65535
	AND aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A AND B:
	tab
	out_ln16 res	
	
	set aaa 65535
	set bbb 0
	AND aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A AND B:
	tab
	out_ln16 res	
	
	set aaa 65535
	set bbb 65535
	AND aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A AND B:
	tab
	out_ln16 res
	
	set aaa 43690
	set bbb 21845
	AND aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A AND B:
	tab
	out_ln16 res		
	
	set aaa 43690
	set bbb 43690
	AND aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A AND B:
	tab
	out_ln16 res		
#endblock

#block test_XOR
	set aaa 0
	set bbb 0
	XOR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A XOR B:
	tab
	out_ln16 res
	
	set aaa 0
	set bbb 65535
	XOR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A XOR B:
	tab
	out_ln16 res	
	
	set aaa 65535
	set bbb 0
	XOR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A XOR B:
	tab
	out_ln16 res	
	
	set aaa 65535
	set bbb 65535
	XOR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A XOR B:
	tab
	out_ln16 res
	
	set aaa 43690
	set bbb 21845
	XOR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A XOR B:
	tab
	out_ln16 res		
	
	set aaa 43690
	set bbb 43690
	XOR aaa bbb res
	msg A:
	tab
	out_ln16 aaa
	msg B:
	tab
	out_ln16 bbb
	msg A XOR B:
	tab
	out_ln16 res		
#endblock

#block test_divmod
	set aaa 11
	set bbb 6
	divmod aaa bbb res mmm
	out_ln aaa
	out_ln bbb
	out_ln res
	out_ln mmm
	line

	set aaa 65535
	set bbb 1
	divmod aaa bbb res mmm
	out_ln aaa
	out_ln bbb
	out_ln res
	out_ln mmm
	line

	set aaa 1
	set bbb 65535
	divmod aaa bbb res mmm
	out_ln aaa
	out_ln bbb
	out_ln res
	out_ln mmm
	line


	set aaa 1
	set bbb 1
	divmod aaa bbb res mmm
	out_ln aaa
	out_ln bbb
	out_ln res
	out_ln mmm
	line

	set aaa 65535
	set bbb 65535
	divmod aaa bbb res mmm
	out_ln aaa
	out_ln bbb
	out_ln res
	out_ln mmm
	line
#endblock

#block test_print
	set aaa 170
	out_ln aaa
    out_ln16 aaa
    out_ln_byte_2 aaa
	line

	set aaa 169
	out_ln aaa
    out_ln16 aaa
    out_ln_byte_2 aaa
	line

	set aaa 0
	out_ln aaa
    out_ln16 aaa
    out_ln_byte_2 aaa
	line

	set aaa 65535
	out_ln aaa
    out_ln16 aaa
    out_ln_byte_2 aaa
	line
#endblock

#dim aaa bbb res mmm

-- test_NOT
-- test_ROL
-- test_OR
-- test_AND
-- test_XOR
-- test_divmod
test_print
